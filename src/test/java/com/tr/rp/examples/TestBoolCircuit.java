package com.tr.rp.examples;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.tr.rp.core.DStatement;
import com.tr.rp.core.Rank;
import com.tr.rp.core.VarStore;
import com.tr.rp.core.rankediterators.ExecutionContext;
import com.tr.rp.core.rankediterators.InitialVarStoreIterator;
import com.tr.rp.core.rankediterators.MarginalizingIterator;
import com.tr.rp.core.rankediterators.RankedIterator;
import com.tr.rp.exceptions.RPLException;
import com.tr.rp.statement.RPLBaseTest;

public class TestBoolCircuit extends RPLBaseTest {

	public void testBoolCircuit() throws RPLException {
		
		// Get solutions generated by example
		DStatement program = BoolCircuit.getProgram();
		RankedIterator<VarStore> it = program.getIterator(new InitialVarStoreIterator(), ExecutionContext.createDefault());
		List<String> vars = new ArrayList<String>();
		vars.add("fx1"); vars.add("fx2"); vars.add("fa1"); vars.add("fa2"); vars.add("fo1");
		it = new MarginalizingIterator(it, vars);
		Map<Integer, Set<Set<String>>> generatedSolutions = new HashMap<Integer,Set<Set<String>>>();
		while (it.next()) {
			VarStore v = it.getItem();
			int rank = it.getRank();
			Set<String> solution = new HashSet<String>();
			for (String var: new String[] { "fx1", "fx2", "fa1", "fa2", "fo1" } ) {
				if (v.getBoolValue(var)) {
					solution.add(var);
				}
			}
			if (generatedSolutions.get(rank) == null) {
				generatedSolutions.put(rank, new HashSet<Set<String>>());
			}
			generatedSolutions.get(rank).add(solution);
		}
				
		// Generate actual solutions
		Map<Integer, Set<Set<String>>> actualSolutions = new HashMap<Integer,Set<Set<String>>>();
		int[] v = new int[] { 0, 0, 0, 0, 0 };
		outer: while (true) {
			if (test(v)) {
				Set<String> solution = getSolution(v);
				int rank = solution.size() - 1;
				if (actualSolutions.get(rank) == null) {
					actualSolutions.put(rank, new HashSet<Set<String>>());
				}
				actualSolutions.get(rank).add(solution);
			}
			v[0]++;
			for (int i = 0; i < 5; i++) {
				if (v[i] == 3) { 
					if (i < 4) {
						v[i] = 0; v[i+1]++; 
					} else {
						break outer;
					}
				}
			}
		}
		
		// Compare
		if (generatedSolutions.equals(actualSolutions)) {
			System.out.println("ok");
		}
		
	}

	private Set<String> getSolution(int[] v) {
		Set<String> res = new HashSet<String>();
		if (v[0] != 0) res.add("fx1");
		if (v[1] != 0) res.add("fx2");
		if (v[2] != 0) res.add("fa1");
		if (v[3] != 0) res.add("fa2");
		if (v[4] != 0) res.add("fo1");
		return res;
	}
	
	private boolean test(int[] v) {
		boolean a1 = false;
		boolean a2 = false;
		boolean a3 = true;

		boolean expectedb1 = true;
		boolean expectedb2 = false;

		int fx1 = v[0];
		int fx2 = v[1];
		int fa1 = v[2];
		int fa2 = v[3];
		int fo1 = v[4];

		boolean l1;
		boolean l2;
		boolean l3;
		
		boolean b1;
		boolean b2;

		if (fx1 == 0) l1 = a1 ^ a2; else l1 = (fx1 == 1? false: true);
		if (fa1 == 0) l2 = (a1 & a2); else l2 = (fa1 == 1? false: true); 
		if (fa2 == 0) l3 = (l1 & a3); else l3 = (fa2 == 1? false: true); 
		if (fx2 == 0) b2 = (l1 ^ a3); else b2 = (fx2 == 1? false: true); 
		if (fo1 == 0) b1 = (l3 | l2); else b1 = (fo1 == 1? false: true); 

		return b1 == expectedb1 && b2 == expectedb2;
	}
	
}
